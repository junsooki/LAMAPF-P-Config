# 需求文档：Event-driven Lifelong Warehouse Routing（匿名箱子 + 匿名送货点）

> 目标读者：coding agent（实现一个可运行的 planner）  
> 关键约束：**箱子无身份**，**送货点等价**，**空载/满载混在一起**，**只在到达事件触发重规划**。

---

## 1. 问题概述

我们在一个仓库拓扑图上有 \(n\) 个移动机器人。机器人在任意时刻可能处于两种状态：

- **Empty（空载）**：需要去某个“需要取货”的取货点拿箱子；
- **Loaded（满载）**：携带一个箱子，需要把箱子送到任意一个送货点（送货点等价）。

系统是 **lifelong**：当某个机器人到达取货点/送货点并完成“取货/卸货”后，会改变其状态（Empty ↔ Loaded），并触发一次全局重规划。平时不重规划。

---

## 2. 核心假设（保证可用网络流做多项式规划的关键）

### 2.1 箱子与送货点同质（最关键）
- 箱子 **无身份**：不要求“箱子 i 必须去送货点 d(i)”。
- 所有送货点 **等价**：送到任意送货点即可算一次“成功投递”。

> 这条假设直接把问题从 PERR（带身份）降为 1-PERR/匿名搬运结构，是我们能用单商品流（max-flow）做 plan 的根本原因。

### 2.2 运动模型（离散时间，同步）
- 时间离散：\(t=0,1,2,\dots\)。
- 每步每个机器人可：
  - 等待（stay）
  - 移动到相邻顶点（move）
- **点冲突（vertex capacity）**：任意时刻每个顶点最多一个机器人占据。

> 我们不需要显式的“边冲突”处理；如果你想完全等价于 MAPF 的标准约束，可以用“边点化”转换，但本需求文档默认仅用点容量 + 时间展开图处理。

### 2.3 取货与送货容量
- 取货点集合 \(P\)：每个取货点在同一轮规划中最多吸收 1 个空载机器人（每点最多派 1 人去取）。
- 送货点集合 \(D\)：每个送货点可设置接收容量（默认每点最多 1 个满载机器人到达；或每点每时刻容量 \(c_d\)）。

### 2.4 事件触发式重规划（event-driven）
- 仅当某个机器人到达取货点/送货点并完成取/卸动作时触发重规划。
- 平时执行上一次规划输出的动作序列。

---

## 3. 输入 / 输出接口（planner 每次被调用时）

### 3.1 输入
- 图 \(G=(V,E)\)
- 当前时间 \(t_0\)
- 当前机器人集合 \(R\)，每个机器人：
  - 当前位置 \(pos(r)\in V\)
  - 状态 \(state(r)\in\{\text{Empty}, \text{Loaded}\}\)
- 当前可用取货点集合 \(P\subseteq V\)
- 当前可用送货点集合 \(D\subseteq V\) 及其容量规则（可选）
- （可选）最大规划窗口上界 \(T_{\max}\)、代价权重（用于 min-cost）

### 3.2 输出
- 对每个机器人 \(r\)，输出一个动作序列（或路径）：
  - \(pos(r, t_0), pos(r, t_0+1), \dots\)
- 并满足：
  - Empty 机器人最终到达某个取货点（且取货点不重复）
  - Loaded 机器人最终到达某个送货点（满足容量）
  - 全程无点冲突

---

## 4. 规划目标（单轮 event 重规划）

单轮重规划解决一个“到下一目标集合”的问题：

- 令 \(E=\{r: state(r)=Empty\}\), \(L=\{r: state(r)=Loaded\}\)
- 目标：为所有机器人生成无冲突路径，使得：
  - 每个 \(r\in E\) 到达某个取货点 \(p\in P\)，且不同机器人到达的取货点互不相同；
  - 每个 \(r\in L\) 到达某个送货点 \(d\in D\)，满足送货容量约束；
- 优先级目标（可选）：
  1) 最小 makespan（所有机器人到达各自目标所需最小时间）
  2) 在该 makespan 下最小总路程/总等待（min-cost）

> 注：执行时可以只执行到**下一次事件**（最早到达目标的机器人完成取/卸），然后再次重规划。

---

## 5. 网络流建模：时间展开图（Time-Expanded Graph）

### 5.1 为什么是网络流
我们要找的是一组在 DAG（时间向前）上的**单位流路径集合**，每条路径对应一个机器人。由于边/点容量均为整数、供给为单位、且图是分层 DAG，max-flow 会给出整数解，可进行路径分解。

### 5.2 基本时间展开节点与边（只用点冲突）
给定一个窗口 \(T\)（表示最多规划到 \(t_0+T\)），构造层 \(t=0,1,\dots,T\)。

经典点容量建法（每个物理点每个时刻容量 1）：
- 为每个 \((v,t)\) 创建两个节点：
  - \(v^{in}_t\), \(v^{out}_t\)
- 加一条容量为 1 的边：
  - \(v^{in}_t \rightarrow v^{out}_t\)（表示“占用该顶点在时刻 t”）
- 运动边（容量 1 或 INF；通常 1 足够）：
  - 对任意 \((v,u)\in E\)，加：
    - \(v^{out}_t \rightarrow u^{in}_{t+1}\)
  - 等待边：
    - \(v^{out}_t \rightarrow v^{in}_{t+1}\)

> 这样：任何单位流在时刻 t 必须经过 \(v^{in}_t\to v^{out}_t\) 才能占用顶点；容量 1 强制同一时刻最多一个机器人占用该点。

---

## 6. 处理“空载/满载混合”的关键：两类目标约束

在单商品流里，难点是：**必须保证空载只算“到取货点”，满载只算“到送货点”**。

这里给出两种实现策略：

---

### 方案 A（推荐，严格满足类型目标，易实现，多项式但可能更保守）：两次流 + 资源预留

#### A1：先规划 Loaded → 送货点（一次 max-flow）
- 只考虑 \(L\) 中机器人作为供给：
  - 为每个 \(r\in L\) 建源边：\(S \rightarrow pos(r)^{in}_0\)，cap=1
- 送货点吸收：
  - 对每个送货点 \(d\in D\)，在任意时间层 \(t\le T\) 加边：
    - \(d^{out}_t \rightarrow T_D\)，cap = 接收容量（默认 1）
- 目标：max-flow 值达到 \(|L|\)（可行），或尽可能大（吞吐最大化）。

得到一组 Loaded 机器人的路径，并记录它们在 \((v,t)\) 的占用（即用了哪些 \(v^{in}_t\to v^{out}_t\) 边）。

#### A2：预留 Loaded 占用，规划 Empty → 取货点（第二次 max-flow）
- 构造一个“残余时间展开图”：将 Loaded 已占用的顶点-时间边 \(v^{in}_t\to v^{out}_t\) 的容量从 1 减到 0（等价于锁住）。
- 对每个 \(r\in E\) 建源边：\(S \rightarrow pos(r)^{in}_0\)，cap=1
- 取货点吸收 + 去重约束：
  - 对每个取货点 \(p\in P\)，在任意时间层 \(t\le T\) 加边：
    - \(p^{out}_t \rightarrow T_P\)，cap=1
- 目标：max-flow 值达到 \(|E|\)。

#### A3：组合输出
- Loaded 用 A1 的路径
- Empty 用 A2 的路径
- 二者共享占用不会冲突（因为 A2 里把 A1 的占用锁死了）

**优点**
- 全程只用单商品 max-flow（多项式）
- 类型目标严格满足（Loaded 必达 D，Empty 必达 P）

**潜在缺点**
- “Loaded 优先”会牺牲一部分全局最优性（但 event-driven + 频繁重规划通常能补回来）
- 在极端拥堵图上可能导致 Empty 无解（可通过增大 T 或改优先级重试）

> 工程上建议：失败时重试策略：交换优先级（Empty 先）、或增大 T、或允许少量“共享但不同时”占用（需要更复杂的联合约束）。

---

### 方案 B（更激进，允许“角色互换”的语义，需要你显式允许交接/交换箱子）：单次流，不区分起始空/满载
如果你允许“箱子可在机器人之间自由交接”，并且不关心哪台机器人最终送到送货点，那么可以把目标改成“在窗口内完成若干次送货与取货事件的总数最大”，不再强制“原本 Loaded 的那台必须去 D”。  
这会让单次 flow 更容易，但改变了语义。本需求默认采用方案 A。

---

## 7. 如何选择窗口 \(T\)（最小 makespan）

对方案 A，每次重规划可用以下方式找到最小可行窗口：
1. 从 \(T=0\) 开始递增（或二分）：
2. 运行 A1，看是否能送达 \(|L|\)；若不行增大 T
3. 在成功的同一个 T 上运行 A2，看是否能送达 \(|E|\)；若不行增大 T
4. 找到第一个同时满足的 \(T^\*\) 作为本轮 makespan

> 二分的前提是“可行性随 T 单调”，通常成立（T 越大越不难）。实现上递增更简单。

---

## 8. 从流解恢复每个机器人的路径（Path Decomposition）

max-flow 输出是边上的流量。由于容量为整数且供给为单位，输出是整数流，可分解成 \(|E|\) 或 \(|L|\) 条单位路径。

分解方法（典型）：
- 对每个源边对应的一单位流，从起点沿着流量=1 的出边一路走到超级汇
- 记录经过的 \((v,t)\) 即得到路径
- 将访问过的边流量减 1，继续下一个机器人

---

## 9. 执行与事件触发重规划

### 9.1 执行
- 得到所有机器人路径后，不一定要执行完整 \(T^\*\) 步。
- 推荐：执行到“下一个事件发生”：
  - 对每个机器人，找到其第一次到达目标集合（Empty 到 P、Loaded 到 D）的时刻
  - 取这些时刻的最小值 \(\Delta\)
  - 执行 \(\Delta\) 步后，触发下一轮重规划

### 9.2 状态更新
在执行 \(\Delta\) 步后：
- 到达取货点的 Empty 机器人：变为 Loaded
- 到达送货点的 Loaded 机器人：变为 Empty
- 更新 P：如果取货点是一次性需求点，被取走则从 P 移除；若仍持续需要取货，则保留
- 更新 D 容量：若有 buffer/吞吐限制，在状态里更新对应容量/队列

---

## 10. 复杂度与实现建议

### 10.1 复杂度
- 单次 max-flow（Dinic）在单位容量网络上通常很快
- 时间展开图规模：
  - 节点：\(\Theta(|V|\cdot T)\)（考虑 in/out 则 \(\times 2\)）
  - 边：\(\Theta((|E|+|V|)\cdot T)\)

每轮可能要跑：
- A1 一次
- A2 一次
- 再加上 T 的递增次数

### 10.2 实现建议
- 用 Dinic（单位容量很适合）
- 维护一个“占用表” reserved[v][t]，用于 A2 锁点
- 若需要更短路径，可把 A1/A2 换成 min-cost max-flow（成本=移动1、等待1等）

---

## 11. 失败与重试策略（工程必备）

当 A2 不可行（Empty 无法在 T 内到达足够取货点）：
1. 增大 \(T\)
2. 交换优先级：先 Empty 再 Loaded（对称地锁点）
3. 随机/启发式打散：对 A1 加 min-cost 优化（减少占用关键瓶颈）
4. 兜底：允许少量局部冲突后用局部修复（例如短窗 CBS repair）

---

## 12. 本模型的边界（哪些改动会立刻变难）
以下任意一条加入都会把问题推向多商品/NP-hard：
- 箱子有身份：必须送到指定送货点
- 订单早绑定：某订单只能在某站完成且绑定进入机器人规划层
- 在单次规划中允许状态转换（途中交接）但还要精确最优（会引入更复杂耦合）

---

## 13. 最小可交付版本（MVP）
建议 coding agent 先实现：
1. 方案 A 的两次 Dinic max-flow
2. 递增 T 找最小可行
3. 流分解成路径
4. 执行到下一事件并重规划

再逐步加：
- min-cost
- 重试策略
- 更真实的容量/冷却模型

---
