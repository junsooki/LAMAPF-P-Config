# Synchronized Two-Stage Model (Batch Pickup -> Batch Drop)

## 定义
这一模型把“一轮”严格拆成两段并同步：
1) 所有机器人必须在同一时刻 `τ` 处于取货点集合 `P`（每点≤1）。
2) 之后所有机器人再从 `P` 出发去卸货点集合 `D`，并在时刻 `T` 完成（每点≤1）。

这等价于“先全体完成取货，再全体一起出发送货”的批处理波次。

## 可行性检查（给定 T 与 τ）
可用 **单层时间展开图 + max-flow** 判定：
- 节点容量 1：对每个 `(v,t)` 做 node-splitting。
- 移动/等待边：`(v,t)->(u,t+1)`，`u=v` 或 `(v,u)∈E`。
- 在时刻 `τ`：只保留 `v∈P` 的节点（或把其它 `(v,τ)` 容量设 0）。
- 在时刻 `T`：只允许流进入 `v∈D` 的节点。
- 超级源连接所有机器人起点 `(s_i,0)`。
- 跑 max-flow，若最大流 = `|R|` 则 `(T,τ)` 可行。

## 仍需处理边冲突
仅用点容量会允许对向交换。
要避免边冲突，需要加 edge-time 容量门（或等价 gadget），
使同一时刻同一条无向边最多通过 1 单位流。

## 什么时候适用
- 适合“严格波次”/“整批同步”的物流流程。
- 可得到该模型下最小 makespan（枚举 `T` 和 `τ`）。

## 不适用的情况
- event-driven 生命周期规划：允许机器人在拿到货后立即出发，
  该模型会强制等待到 τ，导致更大 makespan。
- 任务持续生成（spawn time）的场景：需要多轮触发和状态变化，
  单一 `(T,τ)` 难以表达。

## 结论
同步两段模型在自身定义下是“严格正确”的，
但它改变了原问题语义（更强的同步约束）。
若坚持 event-driven，则不建议把它当作等价替代。
